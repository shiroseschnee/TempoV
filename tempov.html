<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tempov — performance index for competitive chess</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
            font-size: 14px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
        }

        header {
            border-bottom: 1px solid #1a1a1a;
            padding: 20px 0;
            position: sticky;
            top: 0;
            background: #0a0a0a;
            z-index: 100;
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 16px;
            color: #ffffff;
            text-transform: lowercase;
            letter-spacing: 1px;
            cursor: pointer;
        }

        .nav-links {
            display: flex;
            gap: 32px;
            list-style: none;
            align-items: center;
        }

        .nav-links button {
            color: #888;
            text-decoration: none;
            text-transform: lowercase;
            font-size: 13px;
            transition: color 0.2s;
            background: none;
            border: none;
            font-family: inherit;
            cursor: pointer;
            padding: 0;
        }

        .nav-links button:hover,
        .nav-links button.active {
            color: #fff;
        }

        main {
            padding: 48px 0;
            min-height: 60vh;
        }

        .landing {
            max-width: 800px;
            margin: 0 auto;
            padding: 64px 0;
            text-align: center;
        }

        .landing h1 {
            font-size: 48px;
            font-weight: normal;
            text-transform: lowercase;
            margin-bottom: 24px;
            line-height: 1.2;
        }

        .landing p {
            font-size: 16px;
            color: #888;
            margin-bottom: 48px;
            line-height: 1.8;
        }

        .oauth-button {
            background: #1a1a1a;
            color: #fff;
            padding: 16px 32px;
            border: 1px solid #2a2a2a;
            font-size: 14px;
            text-transform: lowercase;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 12px;
        }

        .oauth-button:hover {
            background: #2a2a2a;
            border-color: #3a3a3a;
        }

        .profile-header {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 32px;
            padding: 32px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .profile-avatar {
            width: 80px;
            height: 80px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: #666;
        }

        .profile-info h1 {
            font-size: 24px;
            font-weight: normal;
            text-transform: lowercase;
            margin-bottom: 8px;
        }

        .profile-meta {
            display: flex;
            gap: 24px;
            color: #666;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .lichess-link {
            color: #888;
            text-decoration: none;
        }

        .lichess-link:hover {
            color: #fff;
        }

        .tempov-score {
            background: #111;
            border: 1px solid #1a1a1a;
            padding: 24px;
            margin: 32px 0;
        }

        .score-main {
            display: flex;
            align-items: baseline;
            gap: 16px;
            margin-bottom: 16px;
        }

        .score-value {
            font-size: 48px;
            color: #fff;
            font-weight: bold;
        }

        .score-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 4px;
        }

        .score-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #1a1a1a;
        }

        .breakdown-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .breakdown-value {
            font-size: 20px;
            color: #fff;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin: 32px 0;
        }

        .metric-card {
            background: #111;
            border: 1px solid #1a1a1a;
            padding: 20px;
        }

        .metric-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 12px;
        }

        .metric-value {
            font-size: 28px;
            color: #fff;
            margin-bottom: 8px;
        }

        .metric-description {
            font-size: 12px;
            color: #888;
            line-height: 1.5;
        }

        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin: 48px 0 16px 0;
        }

        .games-table {
            background: #111;
            border: 1px solid #1a1a1a;
            overflow-x: auto;
        }

        .games-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .games-table th {
            text-align: left;
            padding: 16px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            font-weight: normal;
            border-bottom: 1px solid #1a1a1a;
        }

        .games-table td {
            padding: 16px;
            border-bottom: 1px solid #0a0a0a;
            font-size: 13px;
        }

        .games-table tr:last-child td {
            border-bottom: none;
        }

        .result-win { color: #4a9d5f; }
        .result-loss { color: #d45f5f; }
        .result-draw { color: #888; }

        .info-box {
            background: #0f0f0f;
            border-left: 2px solid #2a2a2a;
            padding: 16px;
            margin: 32px 0;
            font-size: 12px;
            color: #888;
            line-height: 1.6;
        }

        .info-box strong {
            color: #fff;
        }

        /* Tier Badge */
        .tier-badge {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            margin-left: 16px;
        }

        .tier-shield {
            width: 40px;
            height: 48px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tier-shield svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .tier-numeral {
            position: absolute;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            color: #0a0a0a;
            text-shadow: none;
        }

        .tier-label {
            font-size: 14px;
            text-transform: lowercase;
            font-weight: normal;
        }

        /* Progress Bar */
        .tier-progress {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #1a1a1a;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
            color: #888;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .info-box strong {
            color: #fff;
        }

        .loading {
            text-align: center;
            padding: 64px 0;
            color: #666;
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 3px solid #1a1a1a;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        footer {
            border-top: 1px solid #1a1a1a;
            padding: 32px 0;
            margin-top: 64px;
            color: #666;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .profile-header {
                grid-template-columns: 1fr;
            }
            .score-breakdown {
                grid-template-columns: 1fr;
            }
            .landing h1 {
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // ============================================================================
        // FIREBASE CONFIGURATION
        // ============================================================================
        // 
        // To enable leaderboard:
        // 1. Go to https://firebase.google.com/
        // 2. Create a new project (or use existing)
        // 3. Add a web app to your project
        // 4. Enable Firestore Database
        // 5. Copy your config and paste below
        // 6. Set FIREBASE_ENABLED to true
        //
        const FIREBASE_ENABLED = true; // Set to true after configuring
        
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyAJXGK1N_O7EvnKIidXpHuJ9JikOTTtNcY",
  authDomain: "tempov-8e4af.firebaseapp.com",
  projectId: "tempov-8e4af",
  storageBucket: "tempov-8e4af.firebasestorage.app",
  messagingSenderId: "119698716444",
  appId: "1:119698716444:web:93869396d22bd87b162cd9",
  measurementId: "G-WTNTWXNPC2"
};

        // Initialize Firebase
        let db = null;
        if (FIREBASE_ENABLED && typeof firebase !== 'undefined') {
            try {
                firebase.initializeApp(FIREBASE_CONFIG);
                db = firebase.firestore();
                console.log('Firebase initialized successfully');
            } catch (error) {
                console.error('Firebase initialization error:', error);
            }
        }

        // Firebase helper functions
        const FirebaseAPI = {
            async saveUserScore(lichessUser, tempoVScore, speedScore) {
                if (!db) return null;
                
                try {
                    const tempoVTier = getTier(tempoVScore.total);
                    const speedTier = speedScore ? getTier(speedScore.total) : null;
                    
                    await db.collection('users').doc(lichessUser.id.toLowerCase()).set({
                        username: lichessUser.username,
                        lichessId: lichessUser.id.toLowerCase(),
                        tempoVScore: tempoVScore.total,
                        tempoVTier: tempoVTier.current.name,
                        speedScore: speedScore ? speedScore.total : null,
                        speedTier: speedTier ? speedTier.current.name : null,
                        gamesAnalyzed: tempoVScore.gameCount,
                        speedGamesAnalyzed: speedScore ? speedScore.gameCount : 0,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                    
                    console.log('Score saved to Firebase');
                    return true;
                } catch (error) {
                    console.error('Error saving score:', error);
                    return false;
                }
            },

            async getLeaderboard(indexType = 'tempov', limit = 100) {
                if (!db) return [];
                
                try {
                    const scoreField = indexType === 'speed' ? 'speedScore' : 'tempoVScore';
                    const snapshot = await db.collection('users')
                        .where(scoreField, '>', 0)
                        .orderBy(scoreField, 'desc')
                        .limit(limit)
                        .get();
                    
                    return snapshot.docs.map((doc, index) => ({
                        rank: index + 1,
                        ...doc.data()
                    }));
                } catch (error) {
                    console.error('Error fetching leaderboard:', error);
                    return [];
                }
            },

            async getTierLeaderboard(tier, indexType = 'tempov', limit = 50) {
                if (!db) return [];
                
                try {
                    const tierField = indexType === 'speed' ? 'speedTier' : 'tempoVTier';
                    const scoreField = indexType === 'speed' ? 'speedScore' : 'tempoVScore';
                    
                    const snapshot = await db.collection('users')
                        .where(tierField, '==', tier)
                        .orderBy(scoreField, 'desc')
                        .limit(limit)
                        .get();
                    
                    return snapshot.docs.map((doc, index) => ({
                        rank: index + 1,
                        ...doc.data()
                    }));
                } catch (error) {
                    console.error('Error fetching tier leaderboard:', error);
                    return [];
                }
            }
        };

        // ============================================================================
        // TIER SYSTEM
        // ============================================================================
        
        const TIERS = [
            { numeral: 'i', name: 'tier i', min: 0, max: 1199, color: '#8B6F47' },
            { numeral: 'ii', name: 'tier ii', min: 1200, max: 1599, color: '#B8B8B8' },
            { numeral: 'iii', name: 'tier iii', min: 1600, max: 1999, color: '#FFD700' },
            { numeral: 'iv', name: 'tier iv', min: 2000, max: 2299, color: '#50C878' },
            { numeral: 'v', name: 'tier v', min: 2300, max: 2599, color: '#0F52BA' },
            { numeral: 'vi', name: 'tier vi', min: 2600, max: 2899, color: '#E0115F' },
            { numeral: 'vii', name: 'tier vii', min: 2900, max: 9999, color: '#9B30FF' }
        ];
        
        const getTier = (score) => {
            if (!score) return null;
            
            const currentTier = TIERS.find(t => score >= t.min && score <= t.max);
            const nextTier = TIERS.find(t => t.min > score);
            
            return {
                current: currentTier,
                next: nextTier,
                pointsToNext: nextTier ? nextTier.min - score : 0,
                progress: currentTier && nextTier ? 
                    ((score - currentTier.min) / (nextTier.min - currentTier.min)) * 100 : 100
            };
        };

        // Tier Badge Component
        function TierBadge({ tier }) {
            if (!tier || !tier.current) return null;
            
            return (
                <div className="tier-badge">
                    <div className="tier-shield">
                        <svg viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 0L0 6V14C0 21 4 28 12 32C20 28 24 21 24 14V6L12 0Z" 
                                  fill={tier.current.color} />
                        </svg>
                        <span className="tier-numeral">{tier.current.numeral}</span>
                    </div>
                    <span className="tier-label" style={{ color: tier.current.color }}>
                        {tier.current.name}
                    </span>
                </div>
            );
        }

        // Progress Bar Component
        function TierProgress({ tier, indexName }) {
            if (!tier || !tier.next) {
                return (
                    <div className="tier-progress">
                        <div className="progress-info">
                            <span style={{ color: tier?.current?.color }}>maximum tier achieved</span>
                        </div>
                    </div>
                );
            }
            
            return (
                <div className="tier-progress">
                    <div className="progress-info">
                        <span>{tier.pointsToNext} points to {tier.next.name}</span>
                        <span>{Math.round(tier.progress)}%</span>
                    </div>
                    <div className="progress-bar-container">
                        <div 
                            className="progress-bar-fill" 
                            style={{ 
                                width: `${tier.progress}%`,
                                background: tier.current.color
                            }}
                        />
                    </div>
                </div>
            );
        }

        // ============================================================================
        // NO CONFIGURATION NEEDED! 
        // Lichess now uses PKCE - no app registration required
        // ============================================================================

        const REDIRECT_URI = window.location.origin + window.location.pathname;

        const LichessOAuth = {
            generateCodeVerifier() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
            },

            async generateCodeChallenge(verifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(verifier);
                const hash = await crypto.subtle.digest('SHA-256', data);
                return btoa(String.fromCharCode(...new Uint8Array(hash)))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            },

            async startAuth() {
                const verifier = this.generateCodeVerifier();
                const challenge = await this.generateCodeChallenge(verifier);
                
                sessionStorage.setItem('oauth_verifier', verifier);
                
                const params = new URLSearchParams({
                    response_type: 'code',
                    client_id: 'tempov.app',
                    redirect_uri: REDIRECT_URI,
                    code_challenge_method: 'S256',
                    code_challenge: challenge,
                    scope: 'preference:read'
                });
                
                window.location.href = `https://lichess.org/oauth?${params.toString()}`;
            },

            async exchangeCode(code) {
                const verifier = sessionStorage.getItem('oauth_verifier');
                
                if (!verifier) {
                    throw new Error('No verifier found');
                }

                const params = new URLSearchParams({
                    grant_type: 'authorization_code',
                    code: code,
                    code_verifier: verifier,
                    redirect_uri: REDIRECT_URI,
                    client_id: 'tempov.app'
                });

                const response = await fetch('https://lichess.org/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: params.toString()
                });

                if (!response.ok) {
                    throw new Error('Token exchange failed');
                }

                const data = await response.json();
                sessionStorage.removeItem('oauth_verifier');
                return data.access_token;
            }
        };

        const LichessAPI = {
            async getProfile(token) {
                try {
                    const response = await fetch('https://lichess.org/api/account', {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });
                    
                    if (!response.ok) throw new Error('Failed to fetch profile');
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching profile:', error);
                    return null;
                }
            },

            async getRecentGames(username, token) {
                try {
                    // Fetch last 300 rated games (reflects current skill level)
                    // Only standard chess variants: blitz, rapid, classical
                    const response = await fetch(
                        `https://lichess.org/api/games/user/${username}?max=300&rated=true&perfType=blitz,rapid,classical&pgnInJson=false`,
                        {
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Accept': 'application/x-ndjson'
                            }
                        }
                    );
                    
                    if (!response.ok) throw new Error('Failed to fetch games');
                    
                    const text = await response.text();
                    const games = text.trim().split('\n').filter(line => line).map(line => JSON.parse(line));
                    return games;
                } catch (error) {
                    console.error('Error fetching games:', error);
                    return [];
                }
            },

            async getSpeedGames(username, token) {
                try {
                    // Fetch last 300 bullet/ultrabullet games for speed index
                    const response = await fetch(
                        `https://lichess.org/api/games/user/${username}?max=300&rated=true&perfType=bullet,ultrabullet&pgnInJson=false`,
                        {
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Accept': 'application/x-ndjson'
                            }
                        }
                    );
                    
                    if (!response.ok) throw new Error('Failed to fetch speed games');
                    
                    const text = await response.text();
                    const games = text.trim().split('\n').filter(line => line).map(line => JSON.parse(line));
                    return games;
                } catch (error) {
                    console.error('Error fetching speed games:', error);
                    return [];
                }
            }
        };

        const calculateTempoVScore = (games, username) => {
            if (!games || games.length === 0) return null;

            let totalPerformance = 0;
            let gameCount = 0;
            const ratings = [];

            games.forEach(game => {
                const isWhite = game.players.white.user?.id === username.toLowerCase();
                const player = isWhite ? game.players.white : game.players.black;
                const opponent = isWhite ? game.players.black : game.players.white;
                
                if (!player.rating || !opponent.rating) return;

                const won = game.winner === (isWhite ? 'white' : 'black');
                const draw = !game.winner;
                
                // Time control weighting
                // Classical = 1.3x, Rapid = 1.15x, Blitz = 1.0x
                let timeControlMultiplier = 1.0; // Default for blitz
                if (game.perf === 'classical') {
                    timeControlMultiplier = 1.3;
                } else if (game.perf === 'rapid') {
                    timeControlMultiplier = 1.15;
                }
                
                const ratingDiff = opponent.rating - player.rating;
                let performanceScore = 75; // Increased from 50 for better score scaling
                
                if (won) {
                    performanceScore += 50 + (ratingDiff > 0 ? ratingDiff / 10 : 0);
                } else if (draw) {
                    performanceScore += 25 + (ratingDiff > 0 ? ratingDiff / 20 : 0);
                } else {
                    performanceScore -= 15 + (ratingDiff < 0 ? Math.abs(ratingDiff) / 10 : 0); // Reduced penalty from -25 to -15
                }
                
                // Apply time control multiplier
                performanceScore *= timeControlMultiplier;

                totalPerformance += performanceScore;
                ratings.push(player.rating);
                gameCount++;
            });

            const avgRating = ratings.reduce((a, b) => a + b, 0) / ratings.length;
            const variance = ratings.reduce((sum, r) => sum + Math.pow(r - avgRating, 2), 0) / ratings.length;
            const consistencyScore = Math.max(0, 500 - variance / 2);
            const volumeScore = Math.min(500, gameCount * 5);

            const performance = totalPerformance / gameCount * 1.5;
            const consistency = consistencyScore;
            const volume = volumeScore;

            return {
                total: Math.round(performance + consistency + volume),
                performance: Math.round(performance),
                consistency: Math.round(consistency),
                volume: Math.round(volume),
                gameCount,
                avgRating: Math.round(avgRating),
                variance: Math.round(variance)
            };
        };

        function Header({ currentView, setCurrentView, isAuthenticated, onLogout }) {
            return (
                <header>
                    <div className="container">
                        <nav>
                            <div className="logo" onClick={() => setCurrentView('landing')}>tempov</div>
                            <ul className="nav-links">
                                {isAuthenticated && (
                                    <>
                                        <li>
                                            <button onClick={() => setCurrentView('profile')}>
                                                profile
                                            </button>
                                        </li>
                                        <li>
                                            <button onClick={() => setCurrentView('leaderboard')}>
                                                leaderboard
                                            </button>
                                        </li>
                                        <li>
                                            <button onClick={onLogout} style={{color: '#d45f5f'}}>
                                                logout
                                            </button>
                                        </li>
                                    </>
                                )}
                            </ul>
                        </nav>
                    </div>
                </header>
            );
        }

        function Landing({ onConnect }) {
            return (
                <div className="landing">
                    <h1>performance index for competitive chess</h1>
                    <p>
                        tempov analyzes your rated games from lichess and produces a multi-dimensional 
                        performance score. track consistency, competitive volume, and results relative 
                        to opponent strength. tempov is not a rating—it's an external measure of sustained 
                        competitive quality.
                    </p>

                    <button onClick={onConnect} className="oauth-button">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                        </svg>
                        connect with lichess
                    </button>

                    <div style={{ marginTop: '32px', fontSize: '12px', color: '#666', lineHeight: '1.8' }}>
                        <p>secure oauth authentication • only you can access your account</p>
                        <p>read-only access • we request account info and game history</p>
                    </div>
                </div>
            );
        }

        function Profile({ lichessUser, games, speedGames, tempoVScore, speedScore }) {
            if (!tempoVScore) {
                return (
                    <div className="loading">
                        <div className="loading-spinner"></div>
                        <p style={{ marginTop: '16px' }}>analyzing last 300 rated games...</p>
                        <p style={{ marginTop: '8px', fontSize: '12px', color: '#666' }}>
                            focusing on recent performance
                        </p>
                    </div>
                );
            }

            const formatDate = (timestamp) => {
                const date = new Date(timestamp);
                const months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
                return `${months[date.getMonth()]} ${date.getDate().toString().padStart(2, '0')}, ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            };

            const getResult = (game, username) => {
                const isWhite = game.players.white.user?.id === username.toLowerCase();
                if (!game.winner) return 'draw';
                return game.winner === (isWhite ? 'white' : 'black') ? 'win' : 'loss';
            };

            const recentGames = games.slice(0, 10);
            
            // Calculate tiers
            const tempoVTier = getTier(tempoVScore.total);
            const speedTier = speedScore ? getTier(speedScore.total) : null;

            return (
                <>
                    <div className="profile-header">
                        <div className="profile-avatar">♟</div>
                        <div className="profile-info">
                            <h1>{lichessUser.username}</h1>
                            <div className="profile-meta">
                                <span>joined {new Date(lichessUser.createdAt).toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}</span>
                                <span>•</span>
                                <a href={`https://lichess.org/@/${lichessUser.username}`} target="_blank" className="lichess-link">
                                    lichess.org/@/{lichessUser.username} ↗
                                </a>
                            </div>
                            <div className="profile-meta">
                                <span>{tempoVScore.gameCount} rated games tracked</span>
                                <span>•</span>
                                <span>last updated now</span>
                            </div>
                        </div>
                    </div>

                    <div className="tempov-score">
                        <div className="score-label">tempov index</div>
                        <div className="score-main">
                            <div className="score-value">{tempoVScore.total}</div>
                            <TierBadge tier={tempoVTier} />
                        </div>
                        
                        <TierProgress tier={tempoVTier} indexName="tempov" />
                        
                        <div className="score-breakdown">
                            <div className="breakdown-item">
                                <div className="score-label">performance vs strength</div>
                                <div className="breakdown-value">{tempoVScore.performance}</div>
                                <div className="metric-description">weighted results against rated opponents</div>
                            </div>
                            <div className="breakdown-item">
                                <div className="score-label">consistency factor</div>
                                <div className="breakdown-value">{tempoVScore.consistency}</div>
                                <div className="metric-description">stability measure (±{tempoVScore.variance} rating points)</div>
                            </div>
                            <div className="breakdown-item">
                                <div className="score-label">competitive volume</div>
                                <div className="breakdown-value">{tempoVScore.volume}</div>
                                <div className="metric-description">game frequency and time control distribution</div>
                            </div>
                        </div>
                    </div>

                    {speedScore && speedScore.gameCount > 0 && (
                        <div className="tempov-score" style={{ marginTop: '16px' }}>
                            <div className="score-label">speed index</div>
                            <div className="score-main">
                                <div className="score-value">{speedScore.total}</div>
                                <TierBadge tier={speedTier} />
                            </div>
                            
                            <TierProgress tier={speedTier} indexName="speed" />
                            
                            <div className="score-breakdown">
                                <div className="breakdown-item">
                                    <div className="score-label">performance vs strength</div>
                                    <div className="breakdown-value">{speedScore.performance}</div>
                                    <div className="metric-description">bullet & ultrabullet results</div>
                                </div>
                                <div className="breakdown-item">
                                    <div className="score-label">consistency factor</div>
                                    <div className="breakdown-value">{speedScore.consistency}</div>
                                    <div className="metric-description">±{speedScore.variance} rating points</div>
                                </div>
                                <div className="breakdown-item">
                                    <div className="score-label">competitive volume</div>
                                    <div className="breakdown-value">{speedScore.volume}</div>
                                    <div className="metric-description">{speedScore.gameCount} speed games</div>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="info-box">
                        <strong>about tempov:</strong> the tempov index measures performance in standard time controls (blitz, rapid, classical). classical games are weighted 1.3x and rapid games 1.15x to account for their greater strategic depth. the speed index measures bullet and ultrabullet performance separately. both are calculated from your last 300 rated games in each category. scores range from 0–3000 and emphasize sustained performance rather than peak achievement.
                    </div>

                    <div className="metrics-grid">
                        <div className="metric-card">
                            <div className="metric-title">avg rating</div>
                            <div className="metric-value">{tempoVScore.avgRating}</div>
                            <div className="metric-description">across analyzed games</div>
                        </div>
                        <div className="metric-card">
                            <div className="metric-title">games analyzed</div>
                            <div className="metric-value">{tempoVScore.gameCount}</div>
                            <div className="metric-description">rated games, all time controls</div>
                        </div>
                        <div className="metric-card">
                            <div className="metric-title">rating variance</div>
                            <div className="metric-value">±{tempoVScore.variance}</div>
                            <div className="metric-description">consistency measure</div>
                        </div>
                    </div>

                    {recentGames.length > 0 && (
                        <>
                            <div className="section-title">recent rated games</div>
                            <div className="games-table">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>date</th>
                                            <th>opponent</th>
                                            <th>rating</th>
                                            <th>time control</th>
                                            <th>result</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {recentGames.map((game, idx) => {
                                            const isWhite = game.players.white.user?.id === lichessUser.id.toLowerCase();
                                            const opponent = isWhite ? game.players.black : game.players.white;
                                            const result = getResult(game, lichessUser.id);
                                            
                                            return (
                                                <tr key={idx}>
                                                    <td>{formatDate(game.createdAt)}</td>
                                                    <td>{opponent.user?.name || 'anonymous'}</td>
                                                    <td>{opponent.rating || 'n/a'}</td>
                                                    <td>{game.perf} {game.clock?.initial ? `${game.clock.initial/60}+${game.clock.increment}` : ''}</td>
                                                    <td className={`result-${result}`}>{result}</td>
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        </>
                    )}
                </>
            );
        }

        function Footer() {
            return (
                <footer>
                    <div className="container">
                        <p>tempov uses lichess oauth pkce. your account data is accessed securely. not affiliated with lichess.</p>
                    </div>
                </footer>
            );
        }

        function Leaderboard() {
            const [leaderboardData, setLeaderboardData] = useState([]);
            const [loading, setLoading] = useState(true);
            const [indexType, setIndexType] = useState('tempov');
            const [filterTier, setFilterTier] = useState(null);

            useEffect(() => {
                loadLeaderboard();
            }, [indexType, filterTier]);

            const loadLeaderboard = async () => {
                setLoading(true);
                
                if (!FIREBASE_ENABLED) {
                    setLoading(false);
                    return;
                }

                const data = filterTier 
                    ? await FirebaseAPI.getTierLeaderboard(filterTier, indexType)
                    : await FirebaseAPI.getLeaderboard(indexType, 100);
                
                setLeaderboardData(data);
                setLoading(false);
            };

            if (!FIREBASE_ENABLED) {
                return (
                    <div>
                        <h1 style={{ fontSize: '24px', fontWeight: 'normal', textTransform: 'lowercase', marginBottom: '8px' }}>
                            global leaderboard
                        </h1>
                        <p style={{ color: '#666', marginBottom: '32px', fontSize: '13px' }}>
                            feature preview
                        </p>

                        <div className="info-box" style={{ background: '#111', borderLeft: '2px solid #FFD700' }}>
                            <strong>leaderboard requires firebase setup</strong>
                            <p style={{ marginTop: '12px', lineHeight: '1.8' }}>
                                to enable the live leaderboard:
                            </p>
                            <ol style={{ marginTop: '12px', marginLeft: '20px', lineHeight: '1.8' }}>
                                <li>create a firebase project at firebase.google.com</li>
                                <li>enable firestore database</li>
                                <li>copy your firebase config</li>
                                <li>paste it in the html file (line ~428)</li>
                                <li>set FIREBASE_ENABLED = true</li>
                            </ol>
                            <p style={{ marginTop: '12px', color: '#888', fontSize: '11px' }}>
                                detailed instructions in the setup guide
                            </p>
                        </div>

                        <div className="leaderboard" style={{ marginTop: '32px' }}>
                            {[
                                { rank: 1, username: 'sample_player_1', tempoVScore: 2847, tempoVTier: 'tier vii' },
                                { rank: 2, username: 'sample_player_2', tempoVScore: 2831, tempoVTier: 'tier vi' },
                                { rank: 3, username: 'sample_player_3', tempoVScore: 2794, tempoVTier: 'tier vi' },
                            ].map(player => (
                                <div className="leaderboard-item" key={player.rank} style={{
                                    display: 'grid',
                                    gridTemplateColumns: '60px 1fr 120px 120px',
                                    gap: '16px',
                                    padding: '16px',
                                    borderBottom: '1px solid #0a0a0a',
                                    alignItems: 'center'
                                }}>
                                    <div style={{ 
                                        fontSize: '16px', 
                                        color: player.rank <= 3 ? '#fff' : '#666',
                                        fontWeight: player.rank <= 3 ? 'bold' : 'normal',
                                        textAlign: 'center'
                                    }}>
                                        {player.rank}
                                    </div>
                                    <span style={{ color: '#fff' }}>{player.username}</span>
                                    <div style={{ textAlign: 'right', fontSize: '18px', color: '#fff' }}>
                                        {player.tempoVScore}
                                    </div>
                                    <div style={{ textAlign: 'right', color: '#666', fontSize: '12px' }}>
                                        {player.tempoVTier}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            }

            return (
                <div>
                    <h1 style={{ fontSize: '24px', fontWeight: 'normal', textTransform: 'lowercase', marginBottom: '8px' }}>
                        global leaderboard
                    </h1>
                    <p style={{ color: '#666', marginBottom: '32px', fontSize: '13px' }}>
                        live rankings • updates in real-time
                    </p>

                    <div style={{ display: 'flex', gap: '16px', marginBottom: '32px', flexWrap: 'wrap' }}>
                        <button 
                            onClick={() => setIndexType('tempov')}
                            style={{
                                background: indexType === 'tempov' ? '#1a1a1a' : 'transparent',
                                color: indexType === 'tempov' ? '#fff' : '#888',
                                padding: '8px 16px',
                                border: '1px solid #2a2a2a',
                                fontSize: '13px',
                                cursor: 'pointer',
                                fontFamily: 'inherit',
                                textTransform: 'lowercase'
                            }}
                        >
                            tempov index
                        </button>
                        <button 
                            onClick={() => setIndexType('speed')}
                            style={{
                                background: indexType === 'speed' ? '#1a1a1a' : 'transparent',
                                color: indexType === 'speed' ? '#fff' : '#888',
                                padding: '8px 16px',
                                border: '1px solid #2a2a2a',
                                fontSize: '13px',
                                cursor: 'pointer',
                                fontFamily: 'inherit',
                                textTransform: 'lowercase'
                            }}
                        >
                            speed index
                        </button>
                    </div>

                    {loading ? (
                        <div className="loading">
                            <div className="loading-spinner"></div>
                            <p style={{ marginTop: '16px' }}>loading leaderboard...</p>
                        </div>
                    ) : (
                        <div className="leaderboard">
                            {leaderboardData.map(player => (
                                <div className="leaderboard-item" key={player.lichessId} style={{
                                    display: 'grid',
                                    gridTemplateColumns: '60px 1fr 120px 120px',
                                    gap: '16px',
                                    padding: '16px',
                                    borderBottom: '1px solid #0a0a0a',
                                    alignItems: 'center'
                                }}>
                                    <div style={{ 
                                        fontSize: '16px', 
                                        color: player.rank <= 3 ? '#fff' : '#666',
                                        fontWeight: player.rank <= 3 ? 'bold' : 'normal',
                                        textAlign: 'center'
                                    }}>
                                        {player.rank}
                                    </div>
                                    <span style={{ color: '#fff' }}>{player.username}</span>
                                    <div style={{ textAlign: 'right', fontSize: '18px', color: '#fff' }}>
                                        {indexType === 'speed' ? player.speedScore : player.tempoVScore}
                                    </div>
                                    <div style={{ textAlign: 'right', color: '#666', fontSize: '12px' }}>
                                        {indexType === 'speed' ? player.speedTier : player.tempoVTier}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        }

        function App() {
            const [currentView, setCurrentView] = useState('landing');
            const [accessToken, setAccessToken] = useState(null);
            const [lichessUser, setLichessUser] = useState(null);
            const [games, setGames] = useState([]);
            const [speedGames, setSpeedGames] = useState([]);
            const [tempoVScore, setTempoVScore] = useState(null);
            const [speedScore, setSpeedScore] = useState(null);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const code = params.get('code');
                
                if (code) {
                    handleOAuthCallback(code);
                } else {
                    const storedToken = localStorage.getItem('tempov_token');
                    if (storedToken) {
                        setAccessToken(storedToken);
                        loadUserData(storedToken);
                    } else {
                        setIsLoading(false);
                    }
                }
            }, []);

            const handleOAuthCallback = async (code) => {
                try {
                    const token = await LichessOAuth.exchangeCode(code);
                    localStorage.setItem('tempov_token', token);
                    setAccessToken(token);
                    
                    window.history.replaceState({}, document.title, window.location.pathname);
                    
                    await loadUserData(token);
                } catch (error) {
                    console.error('OAuth error:', error);
                    setIsLoading(false);
                }
            };

            const loadUserData = async (token) => {
                setIsLoading(true);
                const profile = await LichessAPI.getProfile(token);
                
                if (profile) {
                    setLichessUser(profile);
                    setCurrentView('profile');
                    
                    // Fetch both standard and speed games
                    const userGames = await LichessAPI.getRecentGames(profile.id, token);
                    const userSpeedGames = await LichessAPI.getSpeedGames(profile.id, token);
                    
                    setGames(userGames);
                    setSpeedGames(userSpeedGames);
                    
                    const score = calculateTempoVScore(userGames, profile.id);
                    const speed = calculateTempoVScore(userSpeedGames, profile.id);
                    
                    setTempoVScore(score);
                    setSpeedScore(speed);
                    
                    // Save scores to Firebase for leaderboard
                    if (FIREBASE_ENABLED && score) {
                        await FirebaseAPI.saveUserScore(profile, score, speed);
                    }
                } else {
                    handleLogout();
                }
                
                setIsLoading(false);
            };

            const handleConnect = () => {
                LichessOAuth.startAuth();
            };

            const handleLogout = () => {
                setAccessToken(null);
                setLichessUser(null);
                setGames([]);
                setSpeedGames([]);
                setTempoVScore(null);
                setSpeedScore(null);
                localStorage.removeItem('tempov_token');
                sessionStorage.removeItem('oauth_verifier');
                setCurrentView('landing');
            };

            if (isLoading) {
                return (
                    <>
                        <Header currentView={currentView} setCurrentView={setCurrentView} isAuthenticated={false} />
                        <main>
                            <div className="container">
                                <div className="loading">
                                    <div className="loading-spinner"></div>
                                    <p style={{ marginTop: '16px' }}>loading...</p>
                                </div>
                            </div>
                        </main>
                        <Footer />
                    </>
                );
            }

            return (
                <>
                    <Header
                        currentView={currentView}
                        setCurrentView={setCurrentView}
                        isAuthenticated={!!accessToken}
                        onLogout={handleLogout}
                    />
                    
                    <main>
                        <div className="container">
                            {currentView === 'landing' && (
                                <Landing onConnect={handleConnect} />
                            )}
                            
                            {currentView === 'profile' && lichessUser && (
                                <Profile
                                    lichessUser={lichessUser}
                                    games={games}
                                    speedGames={speedGames}
                                    tempoVScore={tempoVScore}
                                    speedScore={speedScore}
                                />
                            )}
                            
                            {currentView === 'leaderboard' && (
                                <Leaderboard />
                            )}
                        </div>
                    </main>
                    
                    <Footer />
                </>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
